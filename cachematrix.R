## R Programming assignment Week 3.

# These functions convert a matrix into an object that includes the original matrix within an environment that can
# store its inverse on cache (makeCacheMatrix), and compute the inverse of the matrix only if its inverse has not
# already been calculated and stored (cacheSolve).


# makeCacheMatrix takes a matrix (supposed to be always invertible), stores it in its internal environment,
# and returns an object (a list) that contains pointers to internally defined functions to access or change the
# initial matrix or its inverse. The matrix data itself is not returned in the list, but will be accessible when
# running the functions, as it is defined in their environment.

makeCacheMatrix <- function(in.matrix=matrix()) {
      
      inverse.matrix <- NULL                  # When running for the first time, the inverse.matrix value starts null
      
      mutate.matrix <- function(new.value) {
            in.matrix <<- new.value           # Mutator function for the original matrix. Never called here.
            inverse.matrix <<- NULL           # With this we can change the value of the input matrix.
      }
      
      mutate.inverse <- function(calculated.inverse) {   # Mutator function for the inverse matrix. 
            inverse.matrix <<- calculated.inverse        # Used to take the inverse value into this environment.
      }
      
      access.matrix <- function() {           # Accessor function for the original matrix.
            in.matrix                         # Retrieves its data from this environment to do calculations.
      }

      access.inverse <- function() {          # Accessor function for the inverse matrix.
            inverse.matrix                    # Retrieves its data from this environment when already stored.
      }
      
      return(list(inverse.matrix=inverse.matrix,mutate.inverse=mutate.inverse,access.matrix=access.matrix,access.inverse=access.inverse))
                                              # Returns pointers to all defined functions and this environment.
}


# cacheSolve takes the object generated by makeCacheMatrix (including the references to functions) and tries to
# retrieve the inverse data from the makeCacheMatrix environment. If available, it returns it without further
# computing. If not, it computes the inverse, returns it, and also takes its value to the makeCacheMatrix
# environment so that it is stored for next time.

cacheSolve <- function(CacheMatrix) {
      
      inverse.matrix <- CacheMatrix$access.inverse()    # Takes the stored value from the makeCacheMatrix envir.
      
      if(!is.null(inverse.matrix)) {
            message("Inverse matrix already exists. Taking it from cache...")
            return(inverse.matrix)               # If there is a defined value, it is returned immediately.
      }
                                                 # If there is no inverse already calculated, we continue...
      in.matrix <- CacheMatrix$access.matrix()   # The matrix data is taken from the previous environment.
      
      inverse.matrix <- solve(in.matrix)         # The inverse is solved as its generates identity in a linear system.
      CacheMatrix$mutate.inverse(inverse.matrix) # The obtained value is stored in the makeCacheMatrix environment.
      
      return(inverse.matrix)

}
